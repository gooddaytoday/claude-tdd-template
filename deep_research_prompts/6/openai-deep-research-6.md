# Оптимизация TDD‑ориентированного agent harness для Skills, Hooks и Slash‑команд

## Контекст, ограничения и целевой результат

В репозитории задан многофазный TDD‑harness с разнесением обязанностей по шести специализированным субагентам и “жёстким” тех‑гейтам (падение/зелёность тестов, качество, архитектурная интеграция, документация). На практике такой дизайн обычно выигрывает по качеству и воспроизводимости, но начинает “скрипеть” в двух местах: поддерживаемость оркестратора (skill), а также эргономика ускоряющих компонентов (hooks/commands) при работе в разных средах (CLI‑агент и IDE‑агент).  

В этой среде у меня нет рабочего доступа к веб‑источникам и содержимому удалённых URL (поэтому я не могу привести проверяемые цитаты и точные выдержки из документации/постов за 2025–2026). Ниже — максимально прикладной, “инженерный” синтез, опирающийся на предоставленное описание архитектуры и общие практики проектирования агентных harness‑систем (многофазные workflow, контекст‑пакеты, state machine, policy‑as‑code, тестируемые хуки, деградация на IDE‑уровне).

## Модульная структура `tdd-integration` skill как расширяемый state machine

Главная проблема крупного “оркестратор‑skill” в том, что он естественным образом превращается в монолит: правила переходов, чек‑листы качества, сбор контекста, исключения, обработка аварийных ситуаций и “переезды” между фазами оказываются в одном файле. Поддержка становится сложной именно тогда, когда вы хотите добавить новый тип тестов, новый gate, новый ускоряющий shortcut или адаптацию под IDE.

Практичный путь — превратить `tdd-integration` из “большого сценария” в **набор контрактов и модулей**, где root‑skill отвечает только за: (а) сбор минимального контекста, (б) выбор маршрута, (в) управление переходами, (г) единый формат артефактов (outputs). Всё остальное — в под‑skill/шаблоны.

### Контракт фазы и единый формат артефактов

Чтобы фазы были взаимозаменяемыми и расширяемыми, каждой фазе нужен одинаковый “контейнер” данных:

- **Inputs**: контекст задачи (родительская задача + текущая подзадача), список затрагиваемых модулей, тип тестов, ограничения guard/permissions, критерии готовности.
- **Outputs**: что изменено (файлы), какой gate пройден/не пройден, что делать дальше (следующая фаза или возврат), заметки для документации.

Рекомендация: закрепить в skill явный “Phase Result” (как структурированный JSON/YAML‑блок в конце ответа субагента), который main‑оркестратор может парсить “глазами” без догадок. Например, в конце каждого шага субагент обязан выдавать:

- `phase`: red|green|refactor|review|arch|docs  
- `status`: pass|fail|blocked  
- `gate`: краткое описание проверенного условия (например, “тест падает по ожидаемой причине”, “все тесты зелёные”)  
- `files_changed`: список  
- `next_action`: next_phase|retry|escalate_to_main|handoff_to_test_writer  
- `notes_for_task_master`: 3–8 строк, пригодных для сохранения

Это снижает “связность” фаз, исключает хрупкие эвристики и облегчает добавление новых фаз/вариантов.

### Декомпозиция skill на подмодули

Вместо одного `skill.md` имеет смысл держать “пакет”:

- `skill.md` — тонкий диспетчер: выбор сценария и переходов.
- `phases/` — отдельные файлы с инструкциями для каждой фазы (и вариантами, зависящими от типа тестов).
- `checklists/` — независимые чек‑листы (code review, архитектурная интеграция, документация).
- `schemas/` — описание формата артефактов (Phase Result, Context Packet).
- `policies/` — текстовые правила guard‑взаимодействия и “что делать при запрете”.
- `utils/` — общие алгоритмы: определение тест‑типа, сбор затронутых файлов, минимизация контекста.

Преимущество: при расширении (например, добавлении “performance gate” или “security gate”) вы добавляете файлы, а не переписываете монолит.

### Контекст‑пакет как средство стабилизации качества и скорости

Сильный паттерн для многофазных циклов — **Context Packet**: небольшой документ, который каждый субагент получает одинаково, вместо того чтобы пересказывать историю диалога или таск‑контекст в свободной форме.

В вашем сетапе уже есть передача контекста родительской задачи через все фазы. Чтобы упростить и ускорить:

- Сформируйте **один стандартный блок “Context Packet”**, который собирается в Pre‑Phase и дальше либо передаётся дословно, либо обновляется в строго ограниченных местах (например, после GREEN и после ARCH review).
- Храните его в runtime‑файле (gitignored), но с понятной структурой (`.claude/.tdd-context.json` или аналог).  
- Включайте в пакет только то, что реально нужно: цель подзадачи, файлы/модули, API контракты, ограничения, ожидаемые риски интеграции.

Это почти всегда даёт прирост скорости в CLI и уменьшает “дрейф” требований между фазами.

### Ветвление сценариев: feature, bugfix, config/docs

Текущее авто‑правило “для bugfix/docs/config TDD не включать” часто выглядит рационально, но это же место, где качество теряется:

- Для **bugfix** наиболее ценно начать именно с воспроизводящего теста (регрессионного).  
- Для **config** иногда тесты/проверки тоже уместны (линтер‑конфиги, миграции, схемы).
- Для **docs** — можно перейти в “docs workflow”, где gates другие (ссылки, примеры, соответствие коду).

Практичнее сделать **маршруты** внутри общего skill:

- `route: tdd_feature` (обычный цикл)
- `route: tdd_bugfix` (RED начинается с regression‑теста + фикса)
- `route: docs_only` (без RED/GREEN, но с review + docs gate)
- `route: config_change` (минимальные проверки + интеграция)

Важно: это не усложнение, если маршрутизатор живёт отдельно от фаз и использует один и тот же контракт Phase Result.

## Шаблоны reusable skills и “ускоряющие” slash‑pipelines

Скорость цикла обычно ломается не на фазах, а на “переключениях”: запустить нужные тесты, выбрать тип теста, подтянуть контекст задачи, сохранить результат, перейти к следующей фазе. Именно здесь команды и small‑skills дают максимальный выигрыш.

### Командный слой как thin‑wrapper над skill, а не альтернативная логика

Частая ошибка — дублировать логику в командах. Правильнее: команды должны быть **обёртками**, которые:

- собирают минимальные параметры (например, “какой тест‑тип”, “какой подзадаче принадлежит работа”),
- запускают правильный маршрут skill,
- печатают короткий статус и следующий шаг.

Команды не должны содержать правила переходов или чек‑листы — они должны жить в skill/фазах.

### Минимальный набор “команд‑ускорителей” для многофазного цикла

Даже без усложнения можно получить большой выигрыш, если сделать команды, которые закрывают узкие места:

- “Старт цикла” по текущей подзадаче (с автосбором контекста и тест‑типа).
- “Прогон gate” (в одном месте: быстрые тесты/линт/тайп‑чек).
- “Переход к следующей фазе” (если gate пройден).
- “Рековери” (возврат к RED при неожиданном поведении тестов, или возврат к GREEN после refactor).
- “Сохранение артефактов” (Task Master + модульный CLAUDE‑док).

Если CLI поддерживает “slash‑команды” с пайплайном, самая полезная оптимизация — **меньше интерактивных вопросов, больше предсказуемых маршрутов**.

### Шаблон “Phase Runner” как переиспользуемый блок

Обычно в каждой фазе нужны одинаковые элементы: что прочитать, что нельзя трогать, что запустить, какой успех, что делать при провале. Это легко вынести в “phase template”, который затем параметризуется:

- `allowed_tools`
- `read_scope`
- `write_scope`
- `gate_definition`
- `failure_playbook` (что делать при типовых провалах)

Такой шаблон полезен и для расширения (например, добавить фазу “security review”), и для поддержки (правка шаблона улучшает поведение всех фаз).

### Репозитории‑ориентиры и что из них брать

В вашем списке “best practices”‑репозиториев полезнее всего выносить не конкретные промпты, а **организационный паттерн**:

- единые конвенции именования агентов/ролей,
- унифицированные контракт‑форматы выходов,
- отдельные папки для skills/commands/rules,
- примеры “тонких” команд, которые не дублируют логику,
- явные “политики безопасности” как отдельный слой.

В отчётах и примерах стоит ориентироваться на то, что легко тестируется и переносится между средами, а не на “идеальные” промпты без enforcement‑слоя. Среди перечисленных проектов можно отметить как репозитории‑ориентиры для структуры и подходов: entity["organization","VoltAgent","agent framework"], entity["organization","oh-my-opencode","agent prompt collection"], entity["organization","superpowers","agent tooling examples"], entity["organization","wshobson/agents","agent templates repo"].

## Автоактивация skill и безопасность как “policy‑as‑code”

Вы уже сделали сильный ход: enforcement на уровне хука (guard) вместо “надеяться на дисциплину субагентов”. Следующий шаг — сделать так, чтобы (а) автоактивация не раздражала ложными срабатываниями, (б) guard был предсказуемым, тестируемым и корректно деградировал в IDE‑режиме.

### Безопасная автоактивация: трёхсостоянийная логика вместо бинарной

Надёжная схема — “activate / skip / ask” (или “activate / skip / soft‑suggest”), где:

- **activate**: уверенно кодовая задача, изменение поведения, добавление функциональности, исправление дефекта с риском регрессий.
- **skip**: очевидно чистая документация без кода, форматирование, комментарии, орфография, обновление README без примеров.
- **ask/soft‑suggest**: пограничные случаи (конфиг‑изменения, рефакторинги, “почини сборку”, “обнови зависимость”, “настрой линтер”).

Вместо того чтобы “не включать TDD на bugfix”, безопаснее “включать маршрут regression‑TDD на bugfix”. Это повышает качество и почти всегда окупается.

Также хорошо иметь **явный пользовательский override‑маркер** (например, фраза/тег в запросе), который хуки распознают всегда. Важный момент: override должен управлять не только активацией, но и выбором маршрута (feature/bugfix/docs/config).

### Guard‑enforcement: усиление надёжности и переносимости

Текущий guard делает правильные вещи: отслеживает активного субагента, закрывает запись в `tests/**` для фаз кроме RED, перехватывает опасные Bash‑паттерны, защищает файлы enforcement‑слоя, действует “fail‑closed” и отслеживает “семантическое выключение тестов”. Это уже выше среднего по индустрии.

Типовые улучшения, которые повышают устойчивость именно в реальных проектах:

- **Session‑scoping состояния.** Runtime state‑файл, общий для всех окон/процессов, создаёт риск “перетирания” при параллельных сессиях (две IDE, два терминала, CI). Лучше привязать состояние к session id (случайный токен + pid + время), чтобы guard не принимал “чужое” состояние за своё.
- **Чёткий recovery‑playbook при deny.** Сообщение “запрещено” должно сразу говорить, что делать: “передай изменение тестов tdd-test-writer”, “вернись в RED”, “используй main‑агента для легитимного изменения теста” (если это политика).
- **Кросс‑shell перехват.** Если среда включает PowerShell или другие шеллы, нужно учитывать альтернативные команды записи (не только `sed -i`, `tee`, `echo >`). Иначе enforcement становится “дырявым” на Windows‑машинах и в некоторых IDE‑терминалах.
- **Снимки/обновления snapshot‑тестов.** Если проект использует snapshot‑механики, стоит явно решить политику: либо snapshots меняет только тест‑райтер, либо разрешить ограниченный “snapshot update path” (например, через специальную команду, которая временно и контролируемо переводит роль в test‑writer).
- **Тестируемость самого guard.** Для hooks всегда окупается набор unit/integration‑тестов: симуляция PreToolUse событий для Write/Edit/Bash с разными ролями и путями, проверки TTL, проверки deny‑логики и сообщений. Это резко снижает стоимость изменений и повышает доверие к enforcement.

### “Политика first, код second”: отделение правил от имплементации

Если правила “кто что может редактировать” зашиты прямо в TypeScript‑код хука, любое изменение превращается в риск. Практичнее хранить правила как данные:

- список защищённых путей,
- паттерны тест‑директорий,
- матрица “роль → разрешённые пути”,
- разрешённые/запрещённые Bash‑паттерны,
- исключения (например, разрешить правку определённых фикстур).

Тогда код хука — это стабильный интерпретатор политики, а не её единственный носитель. Это особенно важно при адаптации к Cursor.

## Совместимость с Claude Code CLI и Cursor IDE

Ключевая реальность: CLI‑агентные системы обычно позволяют более жёсткий policy/enforcement‑слой (hooks вокруг tool calls). IDE‑агенты чаще работают через правила/инструкции и не всегда предоставляют полноценные “interceptor hooks”. Поэтому стратегия должна быть двухуровневой: **строгий enforcement там, где он поддерживается**, и **компенсирующие механизмы там, где он недоступен**.

image_group{"layout":"carousel","aspect_ratio":"16:9","query":["Claude Code CLI screenshot","Cursor IDE agent mode screenshot","TDD cycle diagram red green refactor"],"num_per_query":1}

### Стратегия совместимости: один “источник истины” + адаптеры сред

Практика, которая лучше всего переживает рост проекта:

- `.claude/` остаётся “источником истины” для фаз, чек‑листов, команд и guard‑политик.
- Для Cursor добавляется “адаптер‑слой”, который:
  - дублирует только то, что Cursor реально понимает (правила, гайдлайны, команды IDE‑уровня),
  - не пытается воспроизвести сложные хуки там, где их нельзя надёжно реализовать.

### Cursor‑режим без hooks: как удержать качество

Если IDE не даёт перехватывать tool‑calls как в CLI‑режиме, вы можете удерживать качество комбинацией:

1) **IDE rules** (процессные правила): “Тесты не меняются вне RED”, “в каждой задаче есть проверяемый gate”, “арх‑ревью обязателен на последней подзадаче”, и т. п.  

2) **Repo‑level проверки** (технический компенсатор): скрипт, который запускается локально/в CI и валидирует инварианты:
- нет изменений в `tests/**` без маркера “RED phase” (маркер может быть в runtime‑файле, в сообщении коммита, в артефакте Task Master или в специальной метке ветки),
- нет `.only/.skip`‑аналогов, которые выключают тесты,
- enforcement‑файлы не модифицированы “в середине цикла” без явного разрешения.  

3) **Рекомендуемый рабочий путь**: запуск “строгого” TDD‑цикла через CLI даже если вы работаете в IDE. В Cursor это обычно означает, что основной цикл идёт через терминал/CLI‑команду, а IDE используется как редактор и для навигации.

### Интеграция с таск‑оркестрацией

Если вы используете Task Master‑подход, полезно сделать так, чтобы Cursor‑режим не разрушал поток “parent → subtask → phases → doc”. Для этого нужен единый “контекст‑пакет” и единый “Phase Result”, описанные выше. Тогда в IDE вы можете хотя бы сохранять структуру артефактов и порядок фаз, даже если enforcement мягче.

При упоминании инструмента таск‑оркестрации уместно подчеркнуть, что это отдельный слой, чувствительный к дрейфу контекста: entity["organization","Task Master AI","claude task orchestration"].

Также стоит явно зафиксировать инфраструктурные различия, чтобы команда не ждала одинакового поведения от разных сред. Для хостинга и совместной разработки сам репозиторный слой обычно живёт на entity["company","GitHub","code hosting platform"].

## План внедрения, тестирование harness и метрики качества

Оптимизация harness‑систем почти всегда ломается на “внесли улучшение, но не можем доказать, что стало лучше”. Поэтому план должен включать не только изменения, но и измеримость.

### Итеративное внедрение без потери текущих гарантий

Наиболее безопасная последовательность:

1) **Ввести контракты (Context Packet + Phase Result)** без изменения поведения фаз. Сначала просто стандартизировать “что фазы обязаны выдавать”.  

2) **Разнести монолитный skill на модули** (phases/checklists/policies/schemas), сохранив существующие тексты инструкций. На этом шаге цель — поддерживаемость, а не поведенческий рефакторинг.  

3) **Перевести guard‑правила в data‑policy формат** и покрыть hooks тестами. Это снижает риск “сломать запреты” при следующей правке.  

4) **Добавить минимальный набор ускоряющих команд**, которые запускают существующий workflow без изменения логики.  

5) **Сделать Cursor‑адаптер**: rules + проверяющий скрипт (локально/CI) как компенсация отсутствующих hooks.  

6) **Только после этого** начинать “умные” оптимизации: маршруты feature/bugfix/config, быстрые тест‑прогоны, расширенные gates.

### Тестирование: что проверять кроме “тесты зелёные”

Для harness‑системы критичны тесты трёх уровней:

- **Hook tests**: симуляция событий Write/Edit/Bash с разными ролями и путями, проверка deny‑сообщений, TTL‑поведения, reset‑логики по окончании субагента.  
- **Workflow regression tests**: несколько “эталонных” задач (маленькая фича, bugfix, рефактор) с ожидаемой последовательностью фаз и ожидаемыми gates.  
- **Policy compliance checks**: отдельный быстрый скрипт, который валидирует инварианты в diff/ветке (особенно полезно для IDE‑режима).

### Метрики: как доказать, что harness стал лучше

Чтобы оптимизация была наблюдаемой, достаточно 5–7 метрик:

- среднее число итераций до прохождения GREEN (на подзадачу),
- доля возвратов на RED после REFACTOR (ранний сигнал слабых тестов),
- доля критических/мажорных замечаний, найденных на CODE REVIEW (и сколько из них автофиксится),
- частота “orphaned code” находок на финальном архитектурном проходе,
- время от начала подзадачи до “DONE” (медиана + p90),
- количество deny‑срабатываний guard (и доля “ложных” по обратной связи),
- доля задач, где bugfix закрыт регрессионным тестом.

Эти метрики помогают не только “ускорять”, но и видеть, где ускорение разрушает качество.

## Вывод по трём фокусным вопросам

Структуру `tdd-integration` проще поддерживать, когда это state machine с явным контрактом выходов и вынесенными в файлы модулями фаз/чек‑листов/политик; тогда добавление новых маршрутов и gates не превращается в правку монолита.  

Наибольший прирост скорости дают reusable phase‑templates и тонкие slash‑обёртки, которые автоматизируют переключения (контекст, запуск проверок, переходы), но не дублируют логику workflow.  

Безопасная автоактивация лучше всего достигается трёхсостоянийной схемой (activate/skip/ask или activate/skip/soft‑suggest), обязательным маршрутом regression‑TDD для bugfix и разделением “политика как данные” от “код перехватчика”; в IDE‑режиме это дополняется репозиторными проверками, поскольку hooks‑enforcement может быть неполным.