# Архитектура и паттерны субагентов для TDD-ориентированного agent harness (2025–2026)

## Исходная архитектура и аудит текущего harness

Текущий шаблон в репозитории на entity["company","GitHub","code hosting platform"] реализует «жёсткий» 6-фазный цикл (Pre-Phase → RED → GREEN → REFACTOR → CODE REVIEW → ARCHITECTURE REVIEW → DOCUMENTATION), зафиксированный в `tdd-integration` skill и продублированный командой `/tdd-integration`. citeturn7view0turn11view1turn11view2

Ключевая сильная сторона текущего AS‑IS — попытка вынести дисциплину TDD из «советов в промпте» в детерминированное исполнение через hooks (TDD Guard). В `.claude/settings.json` подключён `PreToolUse` hook, который запускает `prevent-test-edit.ts` перед любым Write/Edit и блокирует изменения `tests/**` для любых активных субагентов, кроме `tdd-test-writer` (и «main»). citeturn8view2turn8view0

При этом в шаблоне есть важные несостыковки, которые снижают устойчивость harness и напрямую влияют на качество цикла:

Во-первых, `Skill` и `CLAUDE.md` заявляют, что состояние активного субагента будет сбрасываться при `SubagentStop` (т.е. после завершения субагента), чтобы «main» снова мог править тесты. citeturn7view0turn11view2 Но фактически в `.claude/settings.json` нет конфигурации `SubagentStart/SubagentStop` hooks, есть только `PreToolUse` и `UserPromptSubmit`. citeturn8view2 А сам `prevent-test-edit.ts` обрабатывает только `tool_name` = `Task`/`Write`/`Edit` и не реагирует на `hook_event_name` = `SubagentStop`. citeturn8view0 В результате «activeSubagent» может оставаться последним вызванным агентом и продолжать блокировать правки тестов даже тогда, когда фактически вы уже в main‑потоке. Это типичный пример «полуправды» в промпт‑контракте: написано одно, детерминированно обеспечено другое.

Во-вторых, ряд субагентов (особенно `tdd-code-reviewer` и `tdd-architect-reviewer`) описаны как способные «автофиксить» проблемы через делегирование другим субагентам. citeturn10view3turn9view0turn7view0 Однако в актуальной модели Claude Code субагенты не могут порождать других субагентов: вложенная делегация через `Task(...)` внутри субагента не работает. citeturn21view0turn22view0turn34view0 Это означает, что «авто‑fix» реально должен исполняться только в main‑оркестраторе (skill), а субагенты‑ревьюеры обязаны возвращать структурированный запрос на правки (fix‑packet), а не пытаться запускать implementer/refactorer сами.

В-третьих, guard‑сообщение в denial‑reason ссылается на `.cursor/rules/claude-tdd.md`, но такого файла в репозитории нет (404). citeturn8view0turn31view0 Аналогично README ссылается на `SETUP.md`, которого тоже нет (404), что ухудшает воспроизводимость шаблона и делает onboarding менее детерминированным. citeturn11view3turn33view0turn32view1

В сумме: цикл и роли описаны достаточно чётко, но часть «контрактов между компонентами» не совпадает с фактическими ограничениями платформы и/или конфигурацией hooks. Исправление именно этих несоответствий даёт непропорционально большой прирост качества.

## Практики 2025–2026 для субагентов и долгоживущих harness: что важно перенести в шаблон

Современные рекомендации entity["company","Anthropic","ai safety and research company"] для agentic coding и многосессионных систем сводятся к одной мысли: качество определяется не «умностью промпта», а тем, насколько хорошо окружение заставляет агента действовать по правильной траектории и оставлять воспроизводимые артефакты. В исследованиях о long‑running harness подчёркивается, что даже сильные модели склонны пытаться «сделать всё сразу», терять контекст между окнами и объявлять победу без реальной end‑to‑end проверки; устойчивый harness достигается через структурированные артефакты прогресса и жёсткое требование «clean state» в конце сессии (понятного состояния, пригодного для merge). citeturn13view0turn24view1turn24view3

В части субагентов Claude Code (2025–2026) фиксируются несколько платформенных принципов, которые критичны для вашего дизайна ролей:

Субагенты нужны прежде всего для изоляции контекста и контроля инструментов/прав: они держат «шумные» операции (например, длинный вывод тестов) вне main‑контекста и позволяют выдавать каждому специализированному агенту минимально необходимые возможности. citeturn13view4turn22view0turn34view0 Этот тезис напрямую совпадает с вашим подходом «каждая фаза — отдельный субагент», а также с наличием guard‑hook как детерминированного enforcement.

Но одновременно платформа вводит ограничения, которые должны быть отражены в архитектуре harness: субагенты не могут порождать других субагентов, и если нужен «каскад» делегаций, он должен строиться из main‑потока (skill) как последовательность вызовов. citeturn22view0turn21view0turn34view0 Дополнительно важно помнить, что background‑субагенты не имеют MCP‑инструментов; если `tdd-architect-reviewer`/`tdd-documenter` опираются на task-master MCP, их нужно запускать в foreground. citeturn22view0turn35view0

Отдельно в 2025–2026 резко усилился фокус на context engineering как на управление «всем состоянием контекста», а не только system prompt. Ключевые идеи: контекст — конечный ресурс; с ростом контекста растёт “context rot” и падает точность извлечения релевантных деталей; нужно целиться в «правильную высоту» system prompt (не слишком общо и не чрезмерно хрупко), разделять промпт на секции и держать его минимально достаточным, избегая «энциклопедии edge cases». citeturn26view2turn26view3turn26view0 Важное следствие для TDD harness: лучше не пытаться описать «все правила TDD» в каждом агенте, а дать короткие, но канонические примеры и обеспечить детерминированные gate‑проверки + внешнюю память (progress/task logs). citeturn26view0turn26view3turn24view1

Наконец, в 2026 году в инженерных материалах по автономным агентным командам особо подчёркнуто: если «верификатор» несовершенен, агенты оптимизируют не то; поэтому тесты/проверки должны быть максимально качественными и «антиобходными», а вывод harness — коротким и пригодным для машинной обработки (иначе загрязняется контекст). citeturn25view0turn29view2 Это напрямую поддерживает идею вашего TDD Guard и подсказывает, куда его усилить: не только «нельзя редактировать tests/**», но и «нельзя выключать/смягчать тесты косвенными путями» (например, через конфиг/скрипты запуска).

image_group{"layout":"carousel","aspect_ratio":"16:9","query":["Test Driven Development red green refactor cycle diagram","Claude Code subagents context isolation diagram"],"num_per_query":1}

## Ролевые system prompts для шести фаз: структура, которая даёт максимум качества

Ниже — не «переписывание всех промптов», а структурный паттерн, который соответствует практикам 2025–2026: минимальная достаточность, секционирование, валидация результата, формализованный handoff‑пакет и отсутствие ложных обещаний (например, «делегирую fix» внутри субагента). citeturn26view3turn22view0turn21view0

Базовый каркас system prompt для role‑specific агента (универсальный):

1) **Role & Mission**: одно предложение «кто я» + «что считаю успехом».  
2) **Inputs**: какие входы ожидаю (task id, test file path, список изменённых файлов, test command).  
3) **Hard Constraints**: 3–7 правил, которые нельзя нарушать (например, «не трогать tests/**», «не расширять scope»).  
4) **Tool Guidance**: какими инструментами и в каком порядке пользоваться (например, сначала Grep/Glob → потом Read точечно → потом Bash для проверки).  
5) **Self‑verification**: что именно и как я должен проверить перед возвратом результата.  
6) **Output Contract**: фиксированный формат (желательно с «машинно‑парсимыми» маркерами), который main‑оркестратор сможет обрабатывать.

Эта секционированная модель прямо рекомендуется как часть «правильной высоты» system prompt и минимизации хрупкости. citeturn26view3turn26view0turn22view0

Далее — роль‑специфические акценты (с привязкой к вашему текущему AS‑IS и рекомендациями по корректировке).

**RED: tdd-test-writer**  
Текущий агент уже близок к «правильной структуре»: чёткие запреты на имплементацию, явная обязанность подтвердить падение теста и механизм AskUserQuestion только при реальной неопределённости типа теста. citeturn10view0turn11view0turn7view0 Усиление на 2025–2026 уровне обычно делается в трёх местах: (а) требовать, чтобы падение было «смысловым» (assertion/expectation), а не из‑за синтаксиса/импортов; (б) стандартизировать «Test command» и «Failure excerpt» как короткую выжимку (5–15 строк), чтобы не перетаскивать шум в main‑контекст; (в) фиксировать в выходе «Type source» и “confidence” как обязательные поля handoff‑пакета. Подход с «отдельным документом алгоритма выбора test type» уже сделан в `detect-test-type.md` и соответствует принципу «внешних артефактов» вместо раздувания промпта. citeturn11view0turn10view0turn26view3

**GREEN: tdd-implementer**  
Текущий агент корректно фиксирует запрет на редактирование тестов и привязывает успех к прохождению теста, а техническое ограничение поддерживается guard‑hook. citeturn10view1turn8view0 Чтобы приблизиться к лучшим практикам Claude Code, стоит усилить «self‑verification» двумя правилами: (1) запускать именно тот тест, который падал в RED (не полный suite), чтобы уменьшать токен‑шум и повышать причинность; (2) в output‑contract возвращать минимальный «diff‑inventory»: какие файлы тронуты и какие публичные API/exports изменены. Рекомендация «предпочитать запуск одного теста вместо полного набора» прямо отражена в best practices для Claude Code. citeturn10view1turn30view0

**REFACTOR: tdd-refactorer**  
Сейчас агент хорошо сформулирован: изменения только без смены поведения и обязательный прогон тестов. citeturn10view2turn8view0 В 2025–2026 контекстах важный апгрейд — минимизировать «рефактор ради рефактора» и формализовать критерии, когда refactor пропускается, чтобы не накапливать бесполезные итерации и не загрязнять контекст. Ваш «Decision Framework» уже делает это. citeturn10view2 Типовой апгрейд: требовать, чтобы refactor возвращал список «архитектурных инвариантов», которые он не трогал (например, структура модулей, интерфейсы), чтобы архитект‑ревью мог быстрее оценить регрессии.

**CODE REVIEW: tdd-code-reviewer**  
Содержательно чеклист хороший (типизация, ошибки, безопасность). citeturn10view3 Но он конфликтует с платформенным ограничением: субагенты не могут запускать другие субагенты, поэтому «авто‑делегирование» внутри tdd-code-reviewer не должно фигурировать как обязательная часть поведения. citeturn22view0turn21view0turn10view3 Оптимальная структура system prompt для этой роли на практике превращает code-reviewer в **read‑only «оценщика/прокурора»**, который:
- локализует проблемы до конкретных файлов/строк/паттернов,
- присваивает severity,
- формирует «FixRequest» структурой, которую main‑skill сможет отдать implementer/refactorer,
- и отдельно формирует «Regression risks» (что может сломаться) — это снижает количество циклов «исправили одно → сломали другое», что является типичным провалом без eval‑мышления. citeturn29view3turn29view2turn22view0

С точки зрения конфигурации tools это означает: удалить `Task` из tools (он в субагенте всё равно не помогает) и, как правило, не давать `Write/Edit`, чтобы ревьюер не размывал границу ответственности. Такой подход («код‑ревьюер без Edit/Write») приведён как канонический пример в документации по субагентам. citeturn22view0turn34view0turn35view0

**ARCHITECTURE REVIEW: tdd-architect-reviewer**  
Сильная сторона вашего архитектора — конкретные проверки «не висит ли код в воздухе» и формализация Full Task Review на последнем сабтаске. citeturn9view0turn7view0turn11view1 Это хорошо стыкуется с наблюдениями long‑running harness: агентам нужен внешний «план/feature list» и проверка интеграции, иначе они объявляют победу слишком рано. citeturn24view1turn24view0

Но архитектор тоже страдает от обещания «делегировать фиксы implementer’у» внутри субагента. citeturn9view0 В Claude Code субагент должен возвращать в main контекст **интеграционный вердикт + fix‑packet**, а уже skill идёт и запускает implementer/refactorer. citeturn22view0turn21view0 При этом MCP‑инструменты task-master оправданы именно здесь, потому что архитект‑ревью требует parent‑контекста. citeturn9view0turn7view0turn27view2

**DOCUMENTATION: tdd-documenter**  
Документер хорошо оформлен как «последняя фаза», обновляющая task-master и модульные `CLAUDE.md` файлы. citeturn10view4turn7view0turn11view2 Важный нюанс 2025–2026: одна из самых практичных рекомендаций Claude Code — держать root `CLAUDE.md` коротким и выносить «условные workflows» в skills, чтобы не раздувать базовый контекст. citeturn30view0turn26view0 Ваш шаблон уже делает «TDD‑workflow как skill», но документер имеет тенденцию расширять документацию. Оптимизация: фиксировать в промпте документера лимит «только то, что реально нужно следующей фазе/следующему разработчику», и хранить детализацию в task-master (который предназначен для накопления истории). Семантика `update-subtask` как append‑операции с timestamp делает task-master хорошей «исторической памятью» вместо раздувания `CLAUDE.md`. citeturn27view0turn10view4turn30view0

## Хэнд‑офф контракты и self‑verification: что должно быть обязательным между фазами

В Claude Code best practices повторяется: система деградирует, когда агент не может или не привыкает верифицировать результаты; «если не можешь проверить — не поставляй» — это не стилистика, а механизм устойчивости. citeturn30view2turn29view2 Ваш дизайн с gate‑правилами — правильное направление, но для максимума качества в 2025–2026 его нужно «дотянуть» до формализованного handoff‑контракта, который:

- минимален по токенам (чтобы не забивать контекст),
- машиночитаем (чтобы main‑оркестратор мог использовать это без интерпретации),
- и сохраняется вне контекста (task-master + файлы‑артефакты), чтобы переживать компакцию/сессии. citeturn26view2turn26view3turn24view1

Практический паттерн, который хорошо ложится на ваш стек (Claude Code CLI + task-master):

**Единый “Phase Packet” (обязательный handoff для каждой фазы)**  
Минимальный набор полей, который должен возвращать каждый субагент и который main‑skill складывает в task-master details (append) и, опционально, в отдельный файл (`.taskmaster/artifacts/<task-id>/tdd-packet.json`):

- `taskId` и `subtaskId` (если есть),  
- `parentTaskId` (если есть) + короткий `parentGoalSummary` (2–4 строки),  
- `testType` + `typeSource` + `confidence`,  
- `testFilePath`, `testCommand`,  
- `gates`: `{ red: "failed-confirmed", green: "passed-confirmed", refactor: "passed-confirmed" }`,  
- `changedFiles`: список путей,  
- `notes`: короткий список рисков/долгов.

Хранение этого packet’а соответствует сразу двум внешним «памятям»: прогресс‑файлу из long‑running harness паттернов и структурированному note‑taking из context engineering. citeturn24view1turn26view3turn26view0

**Self‑verification как “обязательная часть выхода”, а не процесса**  
У вас уже есть требования «вставь output тестов». citeturn10view0turn10view1turn10view2 Но в 2025–2026 среде полезно сделать два «технически‑удобных» улучшения, чтобы уменьшать шум и повысить проверяемость:

- Возвращать не весь лог, а **короткий excerpt** + **путь к сохранённому логу** (например, `logs/tdd/<task-id>/<phase>.log`). Это следует из принципа «не загрязнять контекст лишним выводом»; в автономных agent-team harness отдельно подчёркивается, что тестовый harness должен печатать «несколько строк», а остальное писать в файлы, пригодные для grep. citeturn25view0turn22view0turn30view2  
- Для интеграционных/длинных тестов добавить режим **быстрой проверки** (smoke subset), чтобы агент не тратил всю сессию на тесты. В исследованиях агентных команд это описывается как компенсация “time blindness” у моделей: по умолчанию нужен быстрый режим, иначе агент будет бесконечно гонять тяжёлые проверки. citeturn25view0turn30view2

**Формализованный “FixRequest” между ревью‑фазами и implement/refactor**  
Из-за ограничения «субагенты не порождают субагентов» корректный handoff должен выглядеть так:

- Code Reviewer/Architect Reviewer возвращают `FixRequest[]` (машиночитаемо): `file`, `location`, `severity`, `why`, `proposedChange`, `verificationCommand`.  
- Main‑skill маршрутизирует FixRequest:  
  - если “logic/type/security” → implementer,  
  - если “structure/duplication/srp” → refactorer.  

Этот паттерн одновременно соответствует идее «грейдеров» и «антиобходности»: вы оцениваете то, что получилось (deterministic checks: lint/type/tests), а затем делаете targeted fix, не заставляя ревьюера «самому чинить». citeturn22view0turn29view2turn10view3turn9view0

## Граница CODE REVIEW и ARCHITECTURE REVIEW: разделять или объединять

С инженерной точки зрения разница между CODE REVIEW и ARCHITECTURE REVIEW — это разница между локальными свойствами изменения и системными свойствами интеграции.

CODE REVIEW отвечает на вопросы: «типизация, ошибки, безопасность, читаемость, SRP/DRY в изменённых файлах, не внесли ли мы очевидную уязвимость или технический долг». Ваш текущий code-reviewer именно так и описан. citeturn10view3turn7view0

ARCHITECTURE REVIEW отвечает на вопросы: «куда подключён компонент, какие у него зависимости, не “висит ли” сервис/утилита без вызова, как это соотносится с parent‑task и проектными конвенциями». Ваш architect-reviewer реализует именно этот слой, включая full task review на последнем сабтаске с построением матрицы интеграции. citeturn9view0turn7view0turn11view1

В 2025–2026 документации по субагентам отдельно рекомендуется проектировать focused subagents (single-responsibility) и ограничивать инструменты — это аргумент в пользу **сохранения разделения** ревью‑фаз. citeturn22view0turn34view0 Дополнительно многoагентные системы показывают, что специализация и параллельная/последовательная координация могут давать значительный прирост качества по сравнению с «одним агентом на всё» (в исследовательских системах — существенный выигрыш у multi‑agent подхода на внутренних eval). citeturn13view1turn22view0

Но есть и реальный cost‑tradeoff note для вашего случая: каждое дополнительное ревью добавляет вызов субагента, который стартует с «свежего контекста», и это повышает latency и риск того, что агент потратит время на ориентацию. citeturn22view0turn23view3 Поэтому практический вывод (как правило лучший для 6‑фазной схемы):

- **Оставить обе фазы**, но сделать их максимально «тонкими» по контексту и максимально формализованными по выходу (FixRequest packets).  
- **Убрать иллюзию авто‑делегирования внутри субагентов** (из‑за ограничения платформы) и перенести orchestration‑повтор (review → fix → retest → re-review) в main‑skill.

Если же в конкретной команде latency важнее, чем «двухуровневая проверка», возможен компромисс: объединённый «reviewer» агент (одна фаза) с двумя секциями отчёта: “CODE QUALITY” и “ARCHITECTURE/INTEGRATION”. Но тогда придётся тщательно следить, чтобы промпт не стал слишком общим или слишком длинным — иначе вы попадёте в зону «неправильной высоты» и потеряете управляемость. citeturn26view3turn22view0

## Programmatic tool calling, permissions и интеграция в Claude Code CLI и Cursor IDE

Переход от «промпт‑только» к «детерминированным механизмам» — ключевой тренд 2025–2026 для агентных систем. В best practices для Claude Code прямо подчёркивается, что hooks — это способ гарантировать действие «с нулём исключений», в отличие от advisory‑инструкций в `CLAUDE.md`. citeturn30view3turn23view3 Ваш guard‑hook — хороший пример, но его нужно довести до полного соответствия документации по hook‑событиям субагентов.

Рекомендуемая коррекция TDD Guard под актуальные правила Claude Code:

- Добавить `SubagentStart`/`SubagentStop` hooks в `.claude/settings.json`, чтобы сбрасывать `activeSubagent` в `main` после завершения любого субагента, как это и заявлено в skill/CLAUDE.md. Документация Claude Code описывает project‑level hooks на события жизненного цикла субагентов и пример конфигурации. citeturn35view0turn21view0turn8view2
- Либо (если хочется оставить один скрипт) расширить `prevent-test-edit.ts`, чтобы он различал `hook_event_name` и на `SubagentStop` писал `activeSubagent: 'main'`. Но это заметно менее «правильный» путь, чем нормальное подключение `SubagentStop` события как отдельного hooks‑триггера. citeturn8view0turn35view0

Вторая зона оптимизации — «программируемая оркестрация» и сокращение токен‑шума. В нововведениях про advanced tool use и code execution with MCP подчёркивается полезность “programmatic tool calling”: когда оркестрационная логика (циклы/условия/фильтрации) исполняется в коде, а модель видит только полезный итог, а не каждое промежуточное значение. citeturn13view3turn23view1 Даже если вы не используете Developer Platform API, идею можно перенести на Claude Code CLI через «локальные скрипты‑помощники», которые:
- запускают тесты и печатают только summary,
- обрезают логи,
- извлекают из task-master нужные поля и выдаёт компактный “context capsule”.

Эта стратегия также согласуется с общими советами context engineering: динамически подтягивать контекст по ссылкам/идентификаторам (пути файлов, команды), а не «заливать всё в prompt». citeturn26view1turn30view2turn22view0

Третья зона — безопасность и автономность. В 2025 году entity["company","Cloudflare","web infrastructure company"] и сама Anthropic акцентировали, что sandboxing снижает число permission prompts и уменьшает риск «approval fatigue», вводя файловую и сетевую изоляцию на уровне ОС. citeturn23view2turn23view6turn23view1 Ваш granular allow/deny/ask в `settings.json` уже соответствует идее «границ», но дальше возможны два практичных шага:
- добавить (по возможности) sandbox boundaries для каталогов с секретами/сборкой (особенно если harness будет использоваться в более автономном режиме); citeturn23view6turn23view2  
- усилить deny‑политику для косвенного «обхода тестов» (например, запрет правок конфигов тест-раннера вне RED‑фазы, если такая угроза наблюдается в вашей практике). Логика антиобходности соответствует современным рекомендациям по eval/грейдерам: агент не должен уметь «выигрывать» за счёт лазеек. citeturn29view2turn8view2turn8view0

Интеграция с entity["company","Cursor","ai code editor"] имеет смысл довести до «симметричной» структуры: Claude Code использует `.claude/skills`, `.claude/hooks`, `.claude/agents`, а Cursor — rules/skills в `.cursor`. По публичной документации Cursor rules дают постоянный контекст на уровне промпта и вставляются в начало model context; это функциональный аналог «постоянных инструкций», которые в Claude Code принято держать короткими и переносить в skills при избыточности. citeturn16search0turn30view0turn26view0 Для практической гармонизации шаблона стоит:
- перестать ссылаться на несуществующий `.cursor/rules/claude-tdd.md` и реально добавить `.cursor/rules/claude-tdd.mdc` с краткой «политикой TDD» и ссылкой на `/tdd-integration`; citeturn31view0turn16search0  
- синхронизировать «термины» и “handoff packet format” между Claude Code и Cursor, чтобы агенты в IDE и CLI возвращали одинаковые маркеры `Test command`, `Changed files`, `FixRequest[]`.

Наконец, для task-master интеграции важно учитывать два факта:
- task-master workflow предполагает постоянное уточнение задач и их тест‑стратегии через `show/update/expand`, и документация рекомендует перед началом работы «развернуть и просмотреть план», убедившись в структуре и dependencies. citeturn27view2turn27view0  
- `update-subtask` описан как append‑операция с timestamp (в отличие от replace‑операции `update-task`), что делает его идеальным механизмом хранения фазных артефактов TDD цикла. citeturn27view0  
Дополнительно task-master поддерживает провайдер “claude-code” (без прямого API key), что полезно для сценариев, когда вы хотите, чтобы планирование задач и их обновления происходили консистентно в той же среде, что и кодинг. citeturn28view0

## Evals и метрики качества harness: как сделать подтверждаемым улучшение субагентов

В 2026 году Anthropic отдельно подчёркивает: хорошие evals выводят разработку агента из «реактивного режима» (пофиксили один баг → получили другой) и дают накапливающийся эффект на протяжении жизненного цикла агента. citeturn23view4turn29view3 Для TDD harness это особенно актуально, потому что у вас уже есть «детерминированные точки контроля» (tests pass/fail, линт, типизация) — то есть вы находитесь в домене, где code-based graders особенно эффективны. citeturn29view2turn29view1

Практичный способ «приземлить» eval‑мышление прямо в ваш репозиторий — тестировать не только продуктовый код, но и сам harness как систему:

1) **Eval для Guard‑механики**: unit‑тесты для `prevent-test-edit.ts`, которые подают ему входной JSON для `PreToolUse` и проверяют, что:
- `Write/Edit` по `tests/**` подтверждается только при `activeSubagent in ['tdd-test-writer','main']`; citeturn8view0turn7view0  
- state корректно обновляется на `Task` и корректно сбрасывается на `SubagentStop` (после вашей фиксации); citeturn35view0turn8view0turn8view2  
- запреты устойчивы к вариациям путей (Windows backslashes и относительные пути), что уже заложено регэкспом и нормализацией путей. citeturn8view0  

2) **Eval для “нечитерства”**: сценарии, которые пытаются «обойти TDD» (например, редактировать jest‑конфиги/скрипты запуска вместо тестов) и подтверждают, что policy либо запрещает такие изменения, либо требует явного “ask”. Этот подход совпадает с рекомендацией «делать грейдеры устойчивыми к лазейкам». citeturn29view2turn30view3turn8view2  

3) **Capability vs regression suites**:  
- capability‑набор для новых улучшений (например, «архитект‑ревью корректно детектит orphaned code и формирует integration FixRequest»), который вначале может иметь низкий pass rate;  
- regression‑набор (почти 100% pass) для того, что уже было стабильно (например, «implementer не может менять tests/**»). Это прямое разделение рекомендовано в материалах про evals. citeturn29view1turn29view3  

4) **Transcript‑ориентированная диагностика**: хранить (или хотя бы периодически анализировать) субагентные транскрипты. Документация Claude Code подчёркивает, что субагентные транскрипты живут отдельно от main‑контекста и переживают компакцию; это удобная база для анализа «где мы теряем качество» и последующей настройки prompts/hooks. citeturn22view0turn23view3turn23view4  

Смысл такой системы: вы сможете измеримо подтвердить, что изменения в prompts/permissions/hooks действительно повышают «TDD‑комплаенс» и снижают число циклов в каждой фазе, а не просто «кажется стало лучше».
