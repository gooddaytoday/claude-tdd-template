# TDD-специфичные практики для AI-агентов: оптимизация harness для Claude Code CLI и Cursor IDE

## Контекст и критерии качества

Цель — повысить надёжность и качество *TDD-ориентированного agent harness* в репозитории `claude-tdd-template`, сохранив совместимость сразу с двумя средами: **Claude Code CLI** (где доступны хуки, permissions и субагенты) и **Cursor IDE** (где поведение агента в значительной степени определяется правилами, планированием и контекстом). citeturn2view0turn29view0

В практиках **2025–2026** в инженерных статьях entity["company","Anthropic","ai research company"] и в гайдлайнах Cursor повторяются три «несущие» идеи, которые хорошо ложатся на вашу архитектуру:

1) **Харнесс важнее “умности” модели**: ключ — в явных инструкциях, управлении инструментами и верификации через артефакты/тесты, а не в попытках «вынудить» модель быть дисциплинированной на словах. citeturn29view0turn23view2turn21view0  
2) **Контекст — ограниченный ресурс**, поэтому нужно не «пихать всё», а системно курировать: что именно модель видит в каждый момент, какие артефакты оставляет между окнами/сессиями. citeturn21view2turn21view0  
3) **Оценка качества agentic-систем требует комбинации детерминированных проверок и модель‑оценщиков**, причём начинать нужно рано, даже с маленьких наборов кейсов (20–30 сценариев). citeturn23view1turn23view2  

Эти принципы удобно превратить в критерии оптимизации вашего TDD-harness:

- **Непроходимость RED/GREEN gates** (невозможность «протиснуться» в GREEN без реального падающего теста и в REFACTOR/REVIEW без реальных зелёных тестов). citeturn5view0turn6view0turn26view0  
- **Невозможность обхода guard‑ограничений через инструменты** (в частности через Bash), и устойчивость к tampering артефактов enforcement. citeturn6view0turn25view1turn26view1  
- **Детерминированная верификация Phase Packets** (защита от «галлюцинаций статуса» и от ложных утверждений «всё прошло» без фактического прогона тестов). citeturn23view2turn9view1turn10view0  
- **Измеримость FixRequest routing и циклов исправлений**, чтобы harness можно было улучшать эволюционно (а не только «интуитивно подкручивать»). citeturn23view2turn23view1turn5view0  

## Что уже реализовано в claude-tdd-template и почему это сильная база

Текущая реализация действительно близка к «эталонному harness» по меркам практик 2025–2026: у вас есть формальный workflow (6 фаз), стандартизованные Phase Packets, структурированный FixRequest‑паттерн и технический guard. citeturn5view0turn9view2turn6view0

Ключевые элементы AS‑IS, которые важно сохранить как опорные:

- **Строгая 6‑фазная state machine** (Pre → RED → GREEN → REFACTOR → CODE REVIEW → ARCHITECTURE REVIEW → DOCUMENTATION) с gate‑условиями. citeturn5view0turn13view0  
- **FixRequest вместо «ревьюер делегирует фикс напрямую»**: ревьюер возвращает структурированный список, а main‑оркестратор делает routing и повторные прогоны тестов. Это соответствует рекомендованным «компонуемым паттернам» (routing/orchestrator‑workers) из статьи про построение эффективных agentic‑систем. citeturn9view2turn5view0turn23view5  
- **Технический TDD Guard на хуках**: перехват `Write/Edit` и запрет модификаций `tests/**` для всех, кроме `tdd-test-writer` и `main`, плюс `SubagentStop` для сброса state. citeturn6view0turn8view0turn25view2  
- **Автоактивация workflow через UserPromptSubmit hook**, чтобы модель не «забывала» включить TDD skill. citeturn7view0turn8view0turn32view0  
- **Сильные контракты субагентов** (tool‑restrictions, self‑verification чеклисты, явные output‑контракты). В терминах Claude Code Docs, это как раз то, зачем нужны субагенты: отдельный контекст, отдельные инструменты и независимые права. citeturn9view0turn9view1turn33view2  

Важный момент совместимости: ваша структура `.claude/skills` + supporting forms отлично совпадает с тем, как Claude Code описывает skills (директория со `SKILL.md`, supporting files, nested discovery, управление тем, кто/когда вызывает skill). citeturn32view1turn5view0  

## Уязвимости и точки обхода RED/GREEN gates, актуальные для 2025–2026

Ниже — наиболее критичные failure‑моды именно для *agentic TDD*, с привязкой к тому, как у вас сейчас устроены hooks/permissions/agents.

### Обход guard через Bash как «побочный канал»

Ваш `prevent-test-edit.ts` проверяет только Tool‑вызовы `Write/Edit`, но **не контролирует, что делает `Bash`**. citeturn6view0turn8view0  
При этом Claude Code прямо предупреждает, что если Bash разрешён, агент может обходить ограничения более «низкоуровневыми» утилитами (и в целом — что попытки ограничивать Bash только правилами по шаблонам хрупкие, и лучше усиливать их хуками `PreToolUse`). citeturn26view1turn25view1  

Практический вывод: даже при идеальной блокировке `Edit(tests/**)` агент всё равно может изменить `tests/**` через shell‑команды, если они попадают под разрешённые паттерны или составляются так, что паттерны не срабатывают. Это напрямую бьёт по задаче «непроходимость gates».

### Fail-open поведение state‑трекинга subagent’а

В `prevent-test-edit.ts` запись state — best‑effort (ошибки записи глушатся), чтение state при ошибке возвращает `activeSubagent: 'main'`. citeturn6view0  
Поскольку `main` входит в `ALLOWED_TEST_WRITERS`, любое «сломанное состояние» фактически превращается в разрешение правки тестов. Это стратегически опасно именно потому, что enforcement должен быть fail‑closed (иначе достаточно одного незаметного сбоя — и guard исчезает ровно в те моменты, когда он нужен).

### Tampering enforcement‑кода (хуки/настройки) и «самоотключение охраны»

Сейчас `settings.json` разрешает `Edit(.claude/**)` и `Write(.claude/**)` на уровне глобальных allow‑правил. citeturn8view0  
Это означает, что любой агент с доступом к `Edit/Write` (включая implementer/refactorer) технически может менять файлы guard’а и skill’а, то есть «подвинуть столбы» enforcement. citeturn6view0turn9view1turn10view0  

Дополнительный красный флаг — зафиксированный в issue‑треке Claude Code кейс, где deny‑правила не защищали hook‑файлы в `~/.claude/hooks/**`, и это позволяло агенту модифицировать собственные ограничения (описано как security gap). citeturn40view0  
Даже если этот конкретный баг не воспроизводится в вашей среде/версии, сам класс проблемы «enforcement‑код должен быть защищён сильнее, чем обычный код» для TDD-harness критичен.

### “Галлюцинации” Phase Packets и ложные статусы

Ваши агенты требуют включать «excerpts» результатов запусков тестов (GREEN/REFACTOR/CODE REVIEW), и это уже хорошая практика. citeturn9view1turn10view0turn9view2  
Но с точки зрения угрозы “Status: passed, но тесты не прогонялись”, это всё ещё мягкая гарантия, потому что excerpt остаётся текстом, который модель может сфабриковать. Именно поэтому в рекомендациях по evals для agentic‑систем отдельно выделяются **детерминированные проверки** (binary tests, outcome verification, tool calls verification) и анализ транскриптов инструментов. citeturn23view3turn23view2  

### Каскадные сбои между фазами (“failure propagation”)

В вашей state machine ошибки могут «перетекать» и усиливаться:

- плохой RED (не тот intent, не тот test type, неустойчивый тест) → GREEN начинает «угадывать», накапливает костыли;  
- слабый GREEN (over-implementation или неправильная API‑форма) → REFACTOR превращается в «спасение» вместо улучшения;  
- недостаточно строгая проверка зелёности в CODE REVIEW/ARCHITECTURE → документер закрепляет в Task Master «ложное знание». citeturn5view0turn10view1turn23view2  

Эта цепочка напрямую связана с тем, что в архитектурах long‑running agents ключевым становится оставление ясных артефактов для следующего «окна» и предотвращение состояний «полусделано и не задокументировано». citeturn21view0turn5view0  

## Усиление проверок и надёжности Phase Packets без ломки текущей архитектуры

Ниже — улучшения, которые сохраняют ваш 6‑фазный цикл и FixRequest‑паттерн, но переводят его ближе к «детерминированным гарантиям» (в духе Claude Code hooks/permissions и рекомендаций по eval‑подходам).

### Сделать gates «evidence-based»: финальное решение принимает не Phase Packet, а реальный прогон тестов

Практика, которая сильнее всего снижает риск галлюцинаций: **main‑оркестратор сам выполняет проверочные команды**, а Phase Packet используется как *инструкция, что запустить*, и как *человекочитаемое суммирование*, но не как источник истины. Это согласуется с тезисом, что agentic evals должны опираться на бинарные/детерминированные проверки и верификацию tool‑исполнения. citeturn23view2turn23view3  

Как это ложится на ваш AS‑IS:

- RED: тест‑райтер возвращает `Test command` + `Test file` + `Failure excerpt`, но main дополнительно запускает команду и проверяет, что падение действительно связано с assertion/expectation (а не с синтаксисом/импортом). Ваш skill уже стандартизирует передачу `Test command`. citeturn5view0turn9view0  
- GREEN/REFACTOR: main запускает ровно тот же `Test command` и фиксирует «зелёность» как факт выполнения. Это «закрывает» класс атак “Status: passed, но тесты не гонялись”. citeturn9view1turn10view0  

Технически это можно усиливать хуками `PostToolUse`/`PostToolUseFailure` (как механизмом «после каждого тест-рана логировать факт и результат»), потому что Claude Code hooks как раз предназначены для детерминированного контроля поведения, а не для надежды, что модель «сама всегда вспомнит». citeturn42search5turn25view1turn42search0  

### Закрыть Bash‑обход TDD Guard теми же hooks, которые Claude Code рекомендует для хрупких мест Bash‑permissions

Claude Code явно указывает, что Bash‑паттерны хрупкие, и рекомендует усиливать их `PreToolUse`‑хуками, которые анализируют фактическую команду и могут deny/ask/allow. citeturn26view1turn25view1  

Для вашего harness это означает: guard должен стать **двухканальным**:

- канал A: текущий `Write/Edit` перехват (у вас уже есть); citeturn6view0  
- канал B: `PreToolUse` перехват для `Bash` (новый), который блокирует любые команды, способные менять `tests/**` и ключевые конфиги тестов вне RED. Пример логики («блокировать разрушительные команды») прямо показан в hooks-документации, то есть паттерн признан официально рабочим. citeturn25view1  

Связанный момент: ваша текущая `settings.json` включает широкие allow‑правила для Bash (в т.ч. файловые утилиты вроде `cp`, `mv`, `echo`). Это удобно, но именно оно делает Bash‑обход реальным. citeturn8view0turn26view0  
Практика 2025–2026 в безопасности Claude Code — переносить «опасное многообразие» из allow‑листов в sandbox/хуки, чтобы не возникало approval fatigue и чтобы команды проверялись на соответствие политике. citeturn34view0turn26view0  

### Перевести guard в fail-closed и «привязать» state к сессии

Сейчас guard при ошибках state‑I/O склоняется к разрешению (через `main`). citeturn6view0  
Для TDD enforcement лучше сделать наоборот:

- если state не прочитан/не записан — это не «main», а «unknown», который **не имеет права** править тесты;  
- state должен включать `session_id` и/или «тайм‑аут актуальности», чтобы stale‑state не жил дольше уместного окна;  
- `SessionStart` hook может сбрасывать state при старте/резюме сессии, что согласуется с тем, что Claude Code поддерживает `SessionStart` как lifecycle‑событие. citeturn25view1turn42search0  

### Защитить enforcement‑код от «самоизменения» отдельной политикой

Даже если игнорировать спорные edge‑кейсы deny‑enforcement на отдельных версиях, базовый принцип для harness: **файлы охраны должны редактироваться значительно реже и по отдельному пути**, иначе они становятся самым простым вектором обхода (вплоть до отключения hook’а). citeturn40view0turn8view0turn6view0  

Практический дизайн (совместимый с вашим FixRequest‑подходом):

- В обычном TDD цикле (RED→…→DOC) любые изменения `.claude/hooks/**`, `.claude/settings.json`, `.claude/skills/**` должны быть либо запрещены, либо требовать явного подтверждения (ask) с очень «громким» reason. Механически это делается тем же `PreToolUse` для `Write/Edit` по пути файла, потому что hooks умеют блокировать конкретный tool‑call. citeturn25view1turn8view0  
- Для эволюции harness можно завести отдельный «maintenance режим» или отдельный «конфиг‑агент» (по сути — специализированный workflow), потому что сама идея «специализированных агентов с отдельными инструментами и правами» — одна из ключевых причин существования subagents. citeturn33view2turn23view4  

### Дополнить Phase Packets полями, которые уменьшают «угадывание требований»

Вы уже включаете `What tests verify`, `Failure excerpt`, `Test command`, `Diff inventory` и списки файлов. citeturn9view0turn9view1  
Чтобы системно уменьшить вероятность «implementer угадывает intent теста», обычно добавляют два типа информации:

- **“Contract surface”**: список ожидаемых экспортов/интерфейсов/ошибок (имена функций, классов, типы входов/выходов), которые тест подразумевает;  
- **“Non-goals / invariants”**: что **не** требуется в этом цикле (предотвращает over-implementation).  

Это напрямую следует из мысли про «context engineering»: модель эффективнее, когда в контекст попадает *ровно то, что нужно для принятия следующего решения*, а не большой «исторический шум». citeturn21view2turn21view0  

## FixRequest routing: как повысить точность маршрутизации и обосновать (или заменить) лимит в 3 цикла

### Уточнить routing как задачу классификации, а не как «правило на глаз»

Сейчас `routeTo` определяется правилами ревьюера (“type/logic/security → implementer”, “structure/duplication/SRP → refactorer”). Это уже зафиксировано и в agent‑контракте, и в checklist‑формах. citeturn9view2turn12view0turn5view0  

Чтобы снизить неверную маршрутизацию на практике, обычно добавляют:

- **confidence** (high/medium/low) и **rationale** (1–2 предложения) в FixRequest — это помогает main‑оркестратору принимать решения при смешанных кейсах (например, “сначала implementer для типов, потом refactorer для структуры”).  
- **dependency ordering**: поле вида `dependsOn: [FixRequestID]` для случаев, когда структурный рефакторинг возможен только после исправления типов/ошибок.  

Это соответствует общему принципу “простые компонуемые паттерны”: вы не усложняете агентов, вы делаете артефакт (FixRequest) более информативным и машинно‑управляемым. citeturn23view4turn23view5  

### Измерять качество routing и превращать метрики в «capability → regression» контур

В “Demystifying evals” предлагается разделять capability‑эвалы (hill‑climb, низкий pass rate) и regression‑эвалы (почти 100% pass rate). На язык FixRequest routing это переводится так: сначала вы улучшаете routing на реальных кейсах, а потом фиксируете набор сценариев, где routing должен оставаться стабильным. citeturn23view3turn23view2  

Минимальный набор измеримых метрик routing, которые обычно дают максимальную отдачу (и легко собираются из уже существующих артефактов Phase Packets):

- **First-route success rate**: доля FixRequest, где первый выбранный `routeTo` привёл к прохождению re-review без переназначения.  
- **Reroute rate**: доля FixRequest, где потребовалась смена `routeTo` (implementer↔refactorer).  
- **Cycles-to-green**: сколько fix‑циклов потребовалось до `Status: passed` ревьюера.  
- **Churn per fix**: число файлов/строк, затронутых fix’ом, как прокси‑метрика «слишком широкий фикс» (может указывать на неверную маршрутизацию или на плохую локализацию issue). citeturn23view2turn5view0turn9view2  

Отдельно полезно добавить **tool-call verification**: фиксировать, что после каждого fix‑цикла реально выполнялась `verificationCommand` (не «на словах»), что полностью согласуется с рекомендациями по agentic evals о верификации инструментальных вызовов и outcome. citeturn23view3turn25view1  

### Адаптивный лимит циклов вместо жёсткого “3”

Текущий лимит max 3 — разумный default как защита от бесконечного thrashing, но он трудно «обосновывается» без данных. Ваш own harness уже содержит подходящий “рычаг”: фикс‑циклы — это небольшая «встроенная evaluation петля». citeturn5view0turn23view2  

Практический подход 2025–2026 (комбинирует безопасность и эффективность):

- **Базовый лимит 3** оставить как safe‑default.  
- Сделать его **адаптивным** по признакам прогресса, которые вы и так можете вычислять:  
  - если количество critical/major FixRequest уменьшается на каждом цикле → разрешать 4–5 циклов (есть явный прогресс);  
  - если один и тот же FixRequest возвращается неизменным 2 раза → эскалация раньше (это признак неверной маршрутизации или неясного intent);  
  - если тесты начинают «краснеть» после каждого фикса → принудительно откатиться и эскалировать как “стабильность тестовой базы”, а не «ещё один цикл». citeturn23view2turn5view0turn10view0  

Эта логика согласуется с практикой “start evals early with small samples”: вы не пытаетесь заранее угадать идеальный лимит, а превращаете реальный цикл в источник измерений и улучшений. citeturn23view1turn23view2  

## Совместимость с Cursor IDE: как перенести дисциплину TDD-harness в среду без Claude Code permissions

Cursor в свежих best practices (январь 2026) подчёркивает, что эффективность agentic coding определяется «харнессом» (инструкции, инструменты, сообщения) и рекомендует два рычага кастомизации: **Rules** (постоянный статический контекст) и **Skills** (динамические workflow/возможности). citeturn29view0turn37view0  

### Зеркалирование TDD skill в `.cursor/rules/` как “always-on дисциплина”

Cursor прямо рекомендует держать правила короткими, включать команды верификации и ссылаться на канонические файлы вместо копирования больших кусков. citeturn37view0turn29view0  
Это идеально совпадает с вашей целью: сделать так, чтобы в Cursor IDE агент «по умолчанию» следовал тому же Red‑Green‑Refactor‑Review, даже если технический enforcement слабее.

Практический дизайн:

- `.cursor/rules/tdd-workflow.md` (или несколько правил по scope):  
  - кратко описать 6 фаз (1–2 строки на фазу),  
  - явно указать “tests first”, “do not change tests during GREEN/REFACTOR”,  
  - указать канонические ссылки на `.claude/skills/tdd-integration/skill.md`, `CLAUDE.md`, и формат FixRequest (как reference, без дубляжа всего контента). citeturn5view0turn14view0turn37view0  
- Блок “Verification steps” в rules (как рекомендует гайд по Cursor rules) — перечислить минимальные команды: unit/integration тесты, typecheck, lint, и правило “вставлять в ответ excerpt вывода”. citeturn29view2turn37view0  

### Использовать Plan Mode и сохранение планов как артефакт‑мост между сессиями

Cursor рекомендует начинать с планирования и сохранять планы в `.cursor/plans/`, чтобы легче резюмировать работу, продолжать после пауз и давать контекст будущим агентам. citeturn37view3turn29view0  
Это напрямую перекликается с идеей long‑running harness у Anthropic: агент должен оставлять ясные артефакты между окнами/сессиями. citeturn21view0turn37view3  

В вашем контексте можно “склеить” артефакты так:

- **Task Master / PRD / таски** — источник «что строим»; citeturn31view0turn5view0  
- **`.cursor/plans/`** — источник «как строим в этой сессии» (включая фазирование TDD); citeturn37view3  
- **Phase Packets** — источник «что получилось и чем подтверждено» (и их можно сохранять как отдельные markdown/JSON артефакты рядом с планом). citeturn5view0turn21view0  

### Task Master AI как единый «контекстный хребет» для обеих сред

Task Master AI позиционируется как система задач для AI‑driven development и прямо описывает установку через MCP как для Cursor, так и для Claude Code, включая пути к `.cursor/mcp.json`, а также возможность уменьшать «контекстную стоимость» через выборочный набор инструментов (`TASK_MASTER_TOOLS`). citeturn31view0turn21view2  
Это полезно в вашей архитектуре, потому что снижает давление на контекст и уменьшает вероятность дрейфа/потери фокуса (что отдельно отмечается и в Cursor best practices про ухудшение качества в длинных диалогах). citeturn31view0turn37view0  

Принципиально: если вы хотите «одинаковую дисциплину» в Claude Code CLI и Cursor IDE, Task Master становится естественным местом, куда можно писать *структурированные итоги фаз* (особенно DOCUMENTATION), потому что он используется в обоих экосистемах. citeturn31view0turn10view1turn5view0  

## Метрики, evals и непрерывное улучшение harness в 2025–2026 стиле

Чтобы harness эволюционировал управляемо, полезно формализовать «что значит улучшился» и собирать минимум telemetry‑показателей на каждый TDD цикл (даже локально, в виде лог‑файлов). В терминах “Demystifying evals”, это превращает ваши TDD‑циклы в смесь capability‑и regression‑эвала: отдельные сценарии выявляют слабые места, а затем закрепляются как регрессия. citeturn23view2turn23view3  

### Минимальный “evaluation pack” для вашего TDD harness

**Gate integrity metrics** (направлены на вопросы 1 и 7 из вашего списка):

- процент циклов, где main‑оркестратор *сам* подтвердил RED‑фейл и GREEN‑пасс через реальный запуск команд (а не только по Phase Packet); citeturn23view3turn5view0  
- число попыток изменить `tests/**` вне RED (и сколько из них было заблокировано hook’ом); citeturn6view0turn25view1  
- число случаев, когда тип падения в RED был “import/module missing” vs “assertion failure” (это поможет принять осознанное решение: «разрешаем двухшаговый RED (compile->assert) или нет»). citeturn9view0turn5view0  

**Fix-routing metrics** (направлены на вопросы 6 и «routeTo correctness»):

- first-route success rate / reroute rate / cycles-to-green (описаны выше); citeturn23view2turn5view0  
- доля FixRequest, где `verificationCommand` реально запускался (tool-call verification). citeturn23view3turn25view1  

**Failure propagation metrics** (направлены на вопрос 5):

- сколько раз issue на CODE REVIEW/ARCHITECTURE связано с тем, что тестовый intent был неполным/двусмысленным (это можно кодировать простым тегом в FixRequest `rootCause: test-intent|impl|structure|integration`). citeturn5view0turn9view2  

### Как начинать eval‑подход «без бюрократии»

В опыте Anthropic multi-agent систем полезно начинать с малого набора кейсов (порядка 20) и быстро видеть эффект от изменений. citeturn23view1  
Для вашего репозитория это может быть набор маленьких задач‑шаблонов (по одной на тип тестов и на тип интеграции), который прогоняется при изменениях guard/skill (или хотя бы вручную как smoke‑suite).

Если понадобятся субъективные оценки (например, «насколько FixRequest понятен и воспроизводим»), подход “LLM‑as‑judge по рубрике” также описан как масштабируемый вариант, но его стоит использовать как вспомогательный слой поверх детерминированных проверок, а не вместо них. citeturn23view1turn23view2